//7th//
#include<stdio.h>
#include<conio.h>
#include<string.h>
void main()
 {
 int a[20],b[30],i,j,k,count,n;
clrscr();
printf("enter frame length:");
scanf("%d",&n);
printf("enter input frame(0's&1's only):");
for(i=0;i<n;i++)
scanf("%d",&a[i]);
i=0;count=1;j=0;
while(i<n)
{
 if(a[i]==1)
{
 b[j]=a[i];
 for(k=i+1;a[k]==1&&k<n&&count<5;k++)
{
 j++; b[j]=a[k];
 count++;
 if(count==5)
{
 j++;
 b[j]=0;
}
i=k;
}
}
else {
 b[j]=a[i];
}
i++;
j++;
}
printf("After stuffing the frame is:");
for(i=0;i<j;i++)
printf("%d",b[i]);
getch();
}

//7th b//
//program for character stuffing
#include<stdio.h>
#include<conio.h>
#include<string.h>
#include<process.h>
void main()
{
{
int i=0,j=0,n,pos; char a[20],b[50],ch;
clrscr();
printf("enter string:\n");
scanf("%s",&a);
n=strlen(a);
printf("enter position\n");
scanf("%d",&pos);
if(pos>n)
{
printf("invalid position,Enter again:");
scanf("%d",&pos);
}
printf("enter the character\n");
ch=getche();
b[0]='d';
b[1]='l';
b[2]='e';
b[3]='s';
b[4]='t';
b[5]='x';
j=6;
while(i<n)
{
if(i==pos-1)
{
b[j]='d';
b[j+1]='l';
b[j+2]='e';
b[j+3]=ch;
b[j+4]='d';
b[j+5]='l';
b[j+6]='e';
j=j+7;
}
if(a[i]=='d'&&a[i+1]=='l'&& a[i+2]=='e')
{
b[j]='d';
b[j+1]='l';
b[j+2]='e;
j=j+3;
}
b[j]=a[i];
i++;
j++;
}
b[j]='d';
b[j+1]='l';
b[j+2]='e';
b[j+3]='e';
b[j+4]='t';
b[j+5]='x';
b[j+6]='\0';
printf("\n frame after stuffing: \n");
printf("%s",b);
getch();
}
//8th //
#include<stdio.h>
struct node
{
 unsigned dist[20];
 unsigned from[20];
}rt[10];
int main()
{
 int costmat[20][20];
 int nodes,i,j,k,count=0;
 printf("\nEnter the number of nodes : ");
 scanf("%d",&nodes);//Enter the nodes
 printf("\nEnter the cost matrix :\n");
 for(i=0;i<nodes;i++)
 {
 for(j=0;j<nodes;j++)
 {
 scanf("%d",&costmat[i][j]);
 costmat[i][i]=0;
 rt[i].dist[j]=costmat[i][j];//initialise
the distance equal to cost matrix
 rt[i].from[j]=j;
 }
 }
 do
 {
 count=0;
 for(i=0;i<nodes;i++)//We choose arbitary vertex k
and we calculate the direct distance from the node i to k
using the cost matrix
 //and add the distance from k to node j
 for(j=0;j<nodes;j++)
 for(k=0;k<nodes;k++)
 if(rt[i].dist[j]>costmat[i][k]+rt[k].dist[j])
 {//We calculate the minimum distance
 rt[i].dist[j]=rt[i].dist[k]+rt[k].dist[j];
rt[i].from[j]=k;
count++;
 }
 }while(count!=0);
 for(i=0;i<nodes;i++)
 {
 printf("\n\n For router %d\n",i+1);
 for(j=0;j<nodes;j++)
 {
 printf("\t\nnode %d via %d Distance %d
",j+1,rt[i].from[j]+1,rt[i].dist[j]);
 }
 }
 printf("\n\n");
 getch();
}


//10th//
#include<stdio.h>
 #include<conio.h>

 int main(void)
{
int data[50],div[16],rem[16];
int datalen, divlen, i,j,k;
int ch;
clrscr();
printf("Enter the data: ");
i = 0;
while((ch = fgetc(stdin)) != '\n')
{
if(ch == '1')
data[i] = 1;
else
data[i] = 0;
i++;
}
datalen = i;
printf("\nEnter the divisor: ");
i = 0;
while((ch = fgetc(stdin)) != '\n')
{
if(ch == '1')
div[i] = 1;
else
div[i] = 0;
i++;
}
divlen = i;
for(i = datalen ; i < datalen + divlen - 1 ; i++)
data[i] = 0;
datalen = datalen + divlen - 1;
for(i = 0 ; i < divlen ; i++)
rem[i] = data[i]; k = divlen-1;
while(k < datalen)
if(rem[0] == 1)
{
for(i = 0 ; i < divlen ; i++)
rem[i] = rem[i] ^ div[i];
}
Else
{
if(k == datalen-1)
break;
for(i = 0 ; i < divlen-1 ; i++)
{
rem[i] = rem[i+1];
printf("%d",rem[i]);
}
rem[i] = data[++k];
printf("%d\n",rem[i]);
}
j=1;
for(i = datalen - divlen + 1 ; i < datalen ; i++)
{
data[i] = rem[j++];
}
printf("\nThe data to be sent is\n");
for(i = 0 ; i < datalen ; i++)
printf("%d",data[i]);
getch();
return 0;
}
